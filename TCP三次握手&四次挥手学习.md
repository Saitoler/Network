本文主要分为两部分：
1. TCP 三次握手知识
2. TCP 四次挥手知识


## TCP 三次握手

### 相关基础知识
- TCP 协议中，主动发起请求的一端称为 **客户端**
- 被动响应连接的一端称为 **服务端**
- 无论是客户端还是服务端，TCP连接建立后，都可以发送和接收数据
- 初始状态，客户端和服务端都为 **CLOSED** 状态；通信开始前，双方都要先创建自己的 **通信控制块 TCB**
- 服务端 **被动** 打开转态， 即创建完 TCB 后，服务端状态变更为 **LISTEN** 状态，等待客户端连接

### 三次握手交互示意
![三次握手交互示意图](https://github.com/Saitoler/Network/blob/master/pics/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

### 三次握手详细过程
#### 第一次握手
客户端 向 服务端 发送连接请求报文，报文头部中包含以下字段：
+ SYN=1  
+ ACK=0
+ seq=x

> SYN=1, ACK=0 表示此报文段为连接请求报文  
> seq=x中， x表示本次TCP通信字节流的初始序号
> TCP 协议规定，SYN=1的报文不包含数据部分，但消耗一个序号

此请求发送后，客户端状态变更为 **SYN_SENT**

#### 第二次握手
服务端收到客户端连接请求后，若同意建立连接，则发送应答报文，包含：
+ SYN=1
+ ACK=1
+ ack=x+1
+ seq=y

> SYN=1, ACK=1 表示该报文为连接请求同意的应答报文
> seq=y中， y表示服务端发送字节流的初始序号
> ack=x+1, 表示服务端已收到客户端上次发送的序号为x的字节流数据，并希望下一个数据从 x+1 开始发送

此请求发送后，服务端状态变更为 **SYN_RCVD**

#### 第三次握手
客户端收到连接请求同意的应答报文后，还要向服务器再发送一个确认报文，表明服务器的同意应答已收到，包含：
+ ACK=1
+ seq=x+1
+ ack=y+1

> ACK=1,表明此报文是同意请求应答的收到确认报文
> seq=x+1,ack=y+1则表明，客户端已收到服务端发来的序号为y的字节流，并表示期望下一个数据从y+1发送；本次发送给服务端的字节流，序号从x+1开始

此请求发送后， 客户端状态变更为 **ESTABLISHED**  
此请求发送后，服务端接收到后，服务端状态也变更为 **ESTABLISED**  

至此，TCP连接建立完成。


### Why 三次握手？
+ 从工业设计的角度讲，三次握手而不是四次握手甚至更多，是因为三次已经完全足够双方确认两者均满足通信要求，更多的握手也只是再对这一资格的确认。 
+ 为什么不是二次握手？ 是 **为了防止失效的连接请求被服务端接收，从而产生错误**
> 假设是二次握手即可，服务端在接收到客户端的请求连接报文后就进入 **ESTABLISHED**状态，客户端当然变化不大，也是在接收到服务器的应答报文后进入 **ESTABLISHED** 状态。
> 状况1： 客户端的连接请求包正常到达服务端，服务端也正常回复了请求连接响应报文，但响应报文因网络超时客户端一直收不到？ 这里就有问题了，客户端不知道是服务端没收到自己的报文还是因为网络自己没收到服务器的响应；同理，服务端不知道网络问题导致客户端没收到自己的响应报文，还是客户端的后续数据自己没收到，服务端就会一直处于 ESTABLISHED 状态，消耗服务端资源
> 状况2： 客户端第一次的请求连接报文因为网络拥塞，服务端没收到；超时后客户端进行重发，服务端正常应答并正常通信，结束后释放连接；此时，第一次发送的请求连接报文到达了服务器，因为是二次握手，服务端进入 ESTABLISHED 状态，等待客户端发送数据或主动发送数据；但此时客户端因为连接已释放早已经进入 CLOSED 状态了，服务端就会一直等下去，消耗服务端连接资源。

综上，三次握手是最低代价的保证客户端、服务端两者在当前条件下均可用的协商机制。

##  TCP 四次挥手

TCP 连接的释放一共四步，因此我们称其为 **四次挥手**  
TCP 连接是双向的，在我们的四次挥手中，前两次用于断开一个方向的连接，后两次用于断开另一个方向的连接。  

在本例中，我们假设客户端先发起请求终止连接，整体交互过程如下图：
![TCP四次挥手交互过程](https://github.com/Saitoler/Network/blob/master/pics/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

### 第一次挥手
客户端认为数据发送完成，则它需要向服务端发送连接释放请求。此请求中只有报头，包含：
- FIN=1
- seq=u

> FIN=1 表明此报文段是一个连接释放请求
> seq=u, 表明 u-1 是客户端向服务端发送的最后一个字节的序号  

此报文发送完成后，客户端状态变更为 **FIN-WAIT-1** 

### 第二次挥手  
服务端收到客户端发送的连接释放请求后，会通知响应的应用层程序，告诉它客户端发起的连接已经释放，此时服务端状态变更为 **CLOSE-WAIT**状态 

而且，服务器会向客户端发送连接释放的应答报文，包含：
- ACK=1
- seq=v
- ack=u+1

> ACK=1 除TCP连接请求外，TCP通讯其他过程中所有数据包的ACK都是1，表示应答。  
> seq=u, 表明服务端向客户端发送的初始数据流字节序号为u  

客户端接收到此报文后，进入 **FIN-WAIT-2** 状态

此阶段完成后，客户端到服务端的连接已经释放，服务端不再接收数据，客户端也不再发送数据。 服务端到客户端的连接仍然 alive，服务端仍可以向客户端发送数据

### 第三次挥手

服务端向客户端发送完所有数据后，向客户端发送连接释放请求，包含：
- FIN=1
- ACK=1
- seq=w
- ack=u+1

> FIN=1 表明这是一个连接释放请求，from the server.
> ACK=1 仍然是对客户端的连接释放请求的应答报文
> seq=w, 表明将要发送的数据字节流序号从w开始， ack=u+1, 表明已接收到客户端的序号u的数据字节流，下一步要接收的是u+1

完成发送后，服务端进入 **LSAT-ACK** 状态

### 第四次挥手
客户端收到连接释放请求后，向服务端发送确认应答。 此时客户端状态变更为 **TIME-WAIT** 状态，此状态持续 2MSL 时间。
- ACK=1
- seq=u+1
- ack=w+1
> 如果此时间段内，服务器没有重发请求，客户端就进入 **CLOSED** 状态，撤销 **TCB**
> 服务端收到确认应答后，状态也变更为 **CLOSED** 状态，并撤销 TCB

### Why 第四次挥手客户端的 TIME-WAIT状态要等待 2MSL 时间？
为了服务端能收到客户端的确认报文！  
如果客户端这边发送结束后直接为 **CLOSED** 状态，如果发往服务端的确认报文丢失，服务端这边等待超时就会重传连接释放请求，但这个时候客户端已经关闭了，不会做出任何响应，
服务端这边就永远无法正确关闭了。

### 为什么是 2MSL ？
- 首先理解什么是 MSL：   
> MSL 是  **Maximum  segment lifetime, 报文最大生存时间** ， 它是任何报文在网络上存在的最长时间，超过这个时间，报文将被丢弃。  
MSL 和 TTL 的区别是什么？ 在于 TTL 的单位是经过的路由的跳数，MSL 的单位是时间。因此，MSL 是大于或等于 TTL 消耗为 0 的时间的，以确保报文已被自然消亡。 2MSL 的时间是从客户端收到 FIN报文后发送 ACK 开始计时的； 如果 TIME-WAIT 时间内，因为客户端的
ACK 没有传输到服务端，服务端又重传了 FIN 报文，那么 2MSL 的时间将会重新计时。  

> 


### Why 建立连接是三次握手，断开连接却需要四次挥手？
我们假设挥手也仅用三次，即去掉服务端单独返回 ACK 的那次，在接收到客户端这边的 FIN 连接终止请求后，立即回复 FIN 报文，这样
有什么问题呢？  
1. 客户端这边随时都可以发起 FIN， 但服务器这边是要一直传输数据的
2. 若果直接在接收到连接终止请求后发起 FIN， 客户端这边看到 FIN 后则会认为服务器能够关闭了，就不再接收其他报文了，但实际上
服务端那边仍然可能会有未发送完的数据，这就与 TCP 的可靠传输不符合了。



