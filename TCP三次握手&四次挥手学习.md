本文主要分为两部分：
1. TCP 三次握手知识
2. TCP 四次挥手知识


## TCP 三次握手

### 相关基础知识
- TCP 协议中，主动发起请求的一端称为 **客户端**
- 被动响应连接的一端称为 **服务端**
- 无论是客户端还是服务端，TCP连接建立后，都可以发送和接收数据
- 初始状态，客户端和服务端都为 **CLOSED** 状态；通信开始前，双方都要先创建自己的 **通信控制块 TCB**
- 服务端 **被动** 打开转态， 即创建完 TCB 后，服务端状态变更为 **LISTEN** 状态，等待客户端连接

### 三次握手交互示意
![三次握手交互示意图](https://github.com/Saitoler/Network/blob/master/pics/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

### 三次握手详细过程
#### 第一次握手
客户端 向 服务端 发送连接请求报文，报文头部中包含以下字段：
+ SYN=1  
+ ACK=0
+ seq=x

> SYN=1, ACK=0 表示此报文段为连接请求报文  
> seq=x中， x表示本次TCP通信字节流的初始序号
> TCP 协议规定，SYN=1的报文不包含数据部分，但消耗一个序号

此请求发送后，客户端状态变更为 **SYN_SENT**

#### 第二次握手
服务端收到客户端连接请求后，若同意建立连接，则发送应答报文，包含：
+ SYN=1
+ ACK=1
+ ack=x+1
+ seq=y

> SYN=1, ACK=1 表示该报文为连接请求同意的应答报文
> seq=y中， y表示服务端发送字节流的初始序号
> ack=x+1, 表示服务端已收到客户端上次发送的序号为x的字节流数据，并希望下一个数据从 x+1 开始发送

此请求发送后，服务端状态变更为 **SYN_RCVD**

#### 第三次握手
客户端收到连接请求同意的应答报文后，还要向服务器再发送一个确认报文，表明服务器的同意应答已收到，包含：
+ ACK=1
+ seq=x+1
+ ack=y+1

> ACK=1,表明此报文是同意请求应答的收到确认报文
> seq=x+1,ack=y+1则表明，客户端已收到服务端发来的序号为y的字节流，并表示期望下一个数据从y+1发送；本次发送给服务端的字节流，序号从x+1开始

此请求发送后， 客户端状态变更为 **ESTABLISHED**  
此请求发送后，服务端接收到后，服务端状态也变更为 **ESTABLISED**  

至此，TCP连接建立完成。


### Why 三次握手？
+ 从工业设计的角度讲，三次握手而不是四次握手甚至更多，是因为三次已经完全足够双方确认两者均满足通信要求，更多的握手也只是再对这一资格的确认。 
+ 为什么不是二次握手？ 是 **为了防止失效的连接请求被服务端接收，从而产生错误**
> 假设是二次握手即可，服务端在接收到客户端的请求连接报文后就进入 **ESTABLISHED**状态，客户端当然变化不大，也是在接收到服务器的应答报文后进入 **ESTABLISHED** 状态。
> 状况1： 客户端的连接请求包正常到达服务端，服务端也正常回复了请求连接响应报文，但响应报文因网络超时客户端一直收不到？ 这里就有问题了，客户端不知道是服务端没收到自己的报文还是因为网络自己没收到服务器的响应；同理，服务端不知道网络问题导致客户端没收到自己的响应报文，还是客户端的后续数据自己没收到，服务端就会一直处于 ESTABLISHED 状态，消耗服务端资源
> 状况2： 客户端第一次的请求连接报文因为网络拥塞，服务端没收到；超时后客户端进行重发，服务端正常应答并正常通信，结束后释放连接；此时，第一次发送的请求连接报文到达了服务器，因为是二次握手，服务端进入 ESTABLISHED 状态，等待客户端发送数据或主动发送数据；但此时客户端因为连接已释放早已经进入 CLOSED 状态了，服务端就会一直等下去，消耗服务端连接资源。

综上，三次握手是最低代价的保证客户端、服务端两者在当前条件下均可用的协商机制。