> 本文中 https 的学习分为两个大的章节：
>  1. https 数据交互具体过程
>  2. https 发展历程

## https 数据交互具体过程

以访问 https://www.baidu.com 为例，数据包交互过程 follow 如下： 
![https 交互抓包](https://github.com/Saitoler/Network/blob/master/pics/https%E4%BA%A4%E4%BA%92%E6%8A%93%E5%8C%85.png)


详细过程解析如下:  
> 鉴于 https 即 http + SSL/TLS ，故本质上还是使用 TCP 协议传输的， 这里在描述时， 忽略掉 TCP 三次握手的过程，仅对 TLS 交互过程进行解析  

![ssl协商数据包](https://github.com/Saitoler/Network/blob/master/pics/SSL%20%E5%8D%8F%E5%95%86%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B.jpg)

### 步骤1
客户端发送  Client Hello 报文开始 SSL 通信，报文中包含：  
> 	- 客户端支持的 SSL 的指定版本  
> 	- 加密组件列表， 如下图所示  
> 	- 随机数 Random_c, 用于生成后续对称密钥交互过程中用于加密的 session keys

![client hello](https://github.com/Saitoler/Network/blob/master/pics/client_hello%E6%95%B0%E6%8D%AE%E5%8C%85.png)

> 	- 在扩展字段中，有一个字段是  server_name 字段， Server Name Indication extension 会包含要访问的具体的 server name 的域名信息：  
![client hello 报文的 server name 扩展字段](https://github.com/Saitoler/Network/blob/master/pics/client_hello_servername.png)

### 步骤2
服务器若可进行 SSL 通信时，会以 Server Hello 报文作为应答，报文中包含：  
> 	- SSL 版本信息  
> 	- 加密组件信息 --- 加密组件你内容是从接收到客户端加密组件内筛选出来的  
> 	- Random_S: 随机数，用于生成后续对称加密交互过程要用的 session key  
![server hello](https://github.com/Saitoler/Network/blob/master/pics/server_hello%E6%95%B0%E6%8D%AE%E5%8C%85.png)  

### 步骤3  
服务器发送 Certificate 报文，报文中包含公开密钥证书  
如下图，网页中查看百度的证书信息， 可以看到根证书下还有两级证书链，在服务器发送 Certificate 报文中，这两个证书信息都包含在报文中。  

![certificate数据包](https://github.com/Saitoler/Network/blob/master/pics/certificate%E6%95%B0%E6%8D%AE%E5%8C%85.png)

### 步骤4  
服务器接着发送 Server Hello Done 报文，通知客户端第一阶段的 SSL 握手协商部分结束  
![server hello done 数据包](https://github.com/Saitoler/Network/blob/master/pics/server_hello_done%E6%95%B0%E6%8D%AE%E5%8C%85.png)。

### 步骤5
客户端发送 Client Key Exchange 报文，报文中包含通信加密中使用的一种称为 Pre-master secret 的随机密码串这个  
pre-master secret 与前面 client 和 server 分别发送的 Random 随机数一起， 客户端与服务端会使用相同的算法，
使用这三个随机数再生成一个随机数， 用于后续的对称密钥加密，即 session key.  

注意，这里报文中还带了 TLS 的版本号，之所以这里再带一次，是因为之前版本号是明文传输的，攻击者可能会恶意更改为较低  
的版本号，从而降低连接的安全系统方便其发起攻击。  

![client key exchange 数据包](https://github.com/Saitoler/Network/blob/master/pics/client_key_exchange%E6%95%B0%E6%8D%AE%E5%8C%85.png)

### 步骤6  
客户端继续发送 Change Cipher Spec 报文， 此报文会告知服务器，接下来的 Client  Finish 消息，将会用刚才协商的密钥  
Session key 来加密。  

### 步骤7  
客户端发送 Client Finished报文，此消息中，会列举客户端上面用到的所有加密字段，并计算出他们的 Hash 值，并用 Session  
key 加密处理。    

### 步骤8  
服务器向客户端发送 Change Cipher Spec 报文， 通知客户端接下来的消息会用 Session key 来加密  

### 步骤9
服务端发送 Server Finished 报文，同样的， 对服务器端整个协商阶段用到的所有字段算一个 Hash, 并用 Session key 加密  

## HTTPS 发展历程
所谓 https, 其实就是 http over ssl/tls ， 一般称为 HTTP Secure， 简称 https.  

### Why https?  
引入 https 的初衷，是为了解决 http 协议下，数据在网络中裸奔的问题 --- 任何人只要想窃听，就可以通过抓包等各种手段，   获取到你的所有网络交互信息，并且这些都是明文的，一抓一个准

### 对称密钥加密
为了解决上面的问题， 就引入了对称密钥加密算法。 所谓对称密钥加密，即只有一个密钥， 数据加密时用它， 解密时也用它。  
客户端与浏览器共用一个密钥，但是问题来了，这个密钥传输过程中也没法保障不被窃取，一旦被窃取了，就和未加密时一模一样了。  

### 非对称密钥加密（一对密钥）  
为了解决2中的问题， 引入了非对称密钥加密算法（服务器一对密钥）。所谓非对称密钥加密，即有两个密钥，一个公钥，一个私钥。公钥加  密的内容可以用私钥解开，反之，私钥加密的内容可以用公钥解开。具体的交互过程如下：    
> 	- 客户端向服务器发起请求
> 	- 服务器将自己的公钥发给客户端 -- 注意，这里的公钥是明文传输的  
> 	- 客户端再次向服务端发送数据时，使用其发过来的公钥进行加密后再传输， **因为只有服务器有私钥，因此这部分数据是绝对安全的**  
> 	- 服务端收到数据后，使用自己的私钥解密后，即可看到原始的明文数据； 服务端使用自己的私钥，对要传输给客户端的数据进行加密，传输之  
> 	- 客户端收到数据后，使用服务端所给的公钥进行解密， 得到真实数据  

这样做有什么问题呢？  
步骤3中， 客户端向服务端传递的数据绝对安全，但是步骤4中，服务端传给客户端的数据安全吗？不安全！   因为步骤2中，公钥是被明文传输的，因此任意截获了所有数据包的人， 都可以使用该公钥解密服务器发过来的数据。  

**也就是说， 一对密钥只能保证单向的数据安全，无法保证双方通信的数据安全。**  

### 非对称密钥加密（两对密钥）
既然服务器一对密钥不够安全，索性客户端这边也来一对密钥。这个时候整个交互过程就成了这样  
> 	- 客户端发起请求， 将自己的公钥明文发送给服务器  
> 	- 服务器明文将自己的公钥，发送给客户端  
> 	- 客户端再次向服务器发起数据请求时，使用服务器的公钥加密该数据发送  
> 	- 服务器收到客户端的数据，用自己的私钥解密数据，得到原始数据； 将客户端要请求的数据，使用客户端所给的公钥加密，发送给客户端  
> 	- 客户端接收到服务器发来的数据时， 用自己的私钥解密数据，得到原始数据  

这个过程安全了吧？ 双向传输的数据都是绝对安全的，但有个问题， 双向的加密解密，太耗时了， 客户端与服务器之间交互太慢了， 怎么解决呢？  

### 对称加密 + 非对称加密  
一种不行， 那我就组合起来用， 非对称加密 + 对称加密 两种加密方式相组合起来，现在的交互过程  
> 	- 客户端向服务器发起请求  
> 	- 服务端将公钥传递给客户端  
> 	- 客户端将后续要用的对称密钥 k， 使用服务器发过来的公钥加密后，发送给服务器  
> 	- 服务器收到数据后用自己的私钥解开，并拿到后续要使用的对称加密密钥 k    
> 	- 服务端将要发送给客户端的数据，使用对称密钥 k 加密后发送到客户端  
> 	- 客户端收到数据后，也使用对称密钥 k 解密即可  

这样子只有一开始双方协商过程中， 将后续要用的对称密钥 k 传递过程用到了非对称密钥加密方式，后续的都是对称加密的数据交互了，简单了很多  

### 密钥计算  
如上方案其实已经能解决很多问题了，但由于设计之初，该对称密钥k 只是一个随机数，而随机数并不是真正完全随机的，   可能会被预测出来，因此也就不安全了。  

这就引出了这一版的方案，既然一个随机数不够安全，那就多搞几个随机数！  
既然一端生成随机数容易被猜出来，那就两端一起来生成！  
现在的交互过程变成了：  
> 	- 客户端发起 SSL  交互，向服务端发送 client hello 报文，报文中包含随机数 random_c  
> 	- 服务端响应 SSL  交互，向客户端回 server hello 报文， 报文中也包含随机数 random_s  
> 	- 服务端响应 SSL  交互，向客户端发送 certificate 报文， 将服务端的公钥发送给客户端  
> 	- 客户端向服务端发送 client key Exchange 报文， 报文中包含第三个随机数称为 Pre-master  secret，    并用服务端发过来的公钥加密发送过去  
> 	- 此时有三个随机数了， random_c, random_s, pre-master secret .客户端和服务端会用相同的算法对这三个随机数进行运算，生成一个新的随机数，这个新的随机数即 session key ，后续客户端和服务端要进行对称加密通信时用到的密钥    

### 数字证书的加入  
对于6中的方案已经很完美了，但思考一个这样的问题：如果有人在浏览器和服务器之间作为中介，来分别代理浏览器和服务器的请求，现有的解决方案是否能够识别到？或者说是否能够避免？  

如下图，攻击者作为中间人，也有自己的一套私钥和公钥， 分别代理了浏览器和服务器的请求后，两者完全是没法发现的  
![中间人攻击](https://github.com/Saitoler/Network/blob/master/pics/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.png)

那对于我们当前的方案来说， 差的就是一个鉴权机制了。
这里就引出了 **第三方认证机构** 的存在， 第三方机构用于对服务器进行信息登记：  
> 	- 第三方机构作为公证人， 有自己的一套公钥和私钥，并公开了自己的公钥，所有人都要记录它的公钥信息  
> 	- 服务器需要去第三方机构登记， 把自己的公钥，名字等信息上报上去  
> 	- 第三方机构拿到这些信息后，将这些信息计算一个 Hash 值，然后 *再用公证人自己的私钥把 Hash 值进行加密* ， **加密后的结果就是数字签名**  
> 	- 第三方机构把登记的信息，和这个数字签名合在一起，封装成一个新的文件发给服务器，**这个新的文件就是数字证书**  

如何进行鉴权呢？  
> 	- 浏览器拿到服务器发过来的证书后，把证书里面的信息计算一个 Hash， 记录为 hash1  
> 	- 浏览器再用已知的第三方机构的公钥，把证书里的数字签名进行解密，得到第三方机构计算的 Hash， 记录为 hash2  
> 	- 判断 hash1 是否等于 hash2， 等于则说明服务器就是我们要访问的那个，而非被中间人篡改了的  













